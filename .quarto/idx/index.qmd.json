{"title":"Guidance connectoModa","markdown":{"yaml":{"title":"Guidance connectoModa","author":"Idrissa DABO","title-block-banner":"#D7DBDD","date-modified":"08/24/2024 01:11","date-format":"MM/D/YYYY, HH:mm","lang":"fr","language":{"title-block-author-single":"RAM Officer","title-block-modified":"Last update"},"format":{"html":{"self-contained":true,"toc":true,"toc-location":"right"}},"editor":"visual"},"headingText":"I- Introduction","containsRefs":false,"markdown":"\n\n```{r echo=FALSE}\n  htmltools::img(src = knitr::image_uri(file.path(\"image/WFP-logo.png\")), \n               alt = 'logo', \n               style = 'position:absolute; top:5px; right:15px; padding:10px; max-width: 13%; max-height: 13%')\n```\n\n```{r setup, include=FALSE}\nknitr::opts_chunk$set(echo = TRUE)\n\nlibrary(DT)\n```\n\n\n**NB** : **The IDs and Tokens are not linked to any WFP account. They are associated with a Gmail account created solely to facilitate understanding of how to use the package and to allow interested colleagues to replicate the exact same example, which they can then adapt to their own projects.**\n\nThe connectoModa package allows you to directly download a database stored in Moda from R. It also provides the ability to retrieve a list of team members with access to the project, along with their access levels. The main advantage is that it allows access to the database even when there are issues with Moda that prevent direct connection.\n\n## II- How to download a database\n\nTo download a database using the **connectoModa** package, it is necessary to log in to Moda at least once to obtain the project Form ID and token.\n\nThe Form ID is a numerical identifier that corresponds to the last digit displayed after selecting the project, as shown in the image below.\n\nTo obtain the token, select **Settings**, then **API Gateway**. The token is in alphanumeric format.\n\nformid ![Form_id](image/form_id.PNG) token ![Token](image/api_key2.PNG){width=\"476\"}\n\nWho has access to the database?\n\n```{r warning=FALSE}\nlibrary(connectoModa)\n\nget_user_moda(form_id = 202344,Token = \"ee9949e8875da3d7bbc63dfb6a8e1ac8d9989030\")\n\n```\n\nDownload the database.\n\n```{r warning=FALSE,message=FALSE}\ndataset <- get_data_moda(form_id = 202344,Token = \"ee9949e8875da3d7bbc63dfb6a8e1ac8d9989030\")\ndatatable(head(dataset,2))\n```\n\nThe package successfully downloaded the database. However, there is an issue: sections appear in the variable names, and for the variable \"sex\", instead of \"male\" and \"female,\" I have the values \"1\" and \"2.\" How can I fix this?\n\n![](image/issue.PNG){fig-align=\"center\" width=\"228\"}\n\n## III- How to have variable names and modalities instead of numbers?\n\n### III-1- Correct variable names\n\nTo correct the problem with variable names, I remove the text before the / symbol as follows\n\n```{r warning=FALSE,message=FALSE}\nnames(dataset) <- stringr::str_remove(names(dataset), \".*\\\\/\")\ndatatable(head(dataset,2))\n\n```\n\n### III-2- How to have the modalities of variables instead of numerical codes\n\nThis is the most important part of the guidance, as it's essential to know each modality associated with the variable codes. To get the modalities we have two choices: either we do it manually using the dplyr package's case_when() function, or we download the questionnaire and do a few manipulations with the for loops. The second method is the most appropriate, as manually recoding a database of over 500 variables can be tedious.\n\nTo use this method, you need to download the questionnaire from Moda and import it into R .\n\nThe questionnaire used in this example is available below:\n\n```{r echo=FALSE}\nxfun::embed_file(\"questionnaire.xlsx\")\n```\n\nThe first column of the **survey** sheet contains the elements of the first column of the **choice** sheet. For example, with select_one **sex** we find **sex** in the first column of the choice sheet. The following steps will provide the modalities:\n\n1.  Import survey sheet from questionnaire\n\n2.  Import choices sheet from questionnaire\n\n3.  Split the first column of the survey sheet into 2 columns\n\n4.  Create a Null vector in which to add all the variable names in the imported database that are identical to the names in column 2 of the survey sheet\n\n5.  Transform the vector into a dataframe, then use the vlooukup function to add the variables obtained by separating the first column of the survey sheet.\n\n6.  Make a left join with the choices sheet to obtain a dataframe with the choices elements.\n\n7.  Define the columns on which to apply the vlookup and create a function that associates each variable with its column content to facilitate the vlookup.\n\n8.  Associate each variable with modalities and its column contents.\n\n9.  (**Optional**) Remove duplicated variable names and give variable names to columns with empty names\n\n10. Apply the vlookup to the entire database.\n\n```{r warning=FALSE,message=FALSE}\n# Step 1\nsurvey_sheet <- readxl::read_xlsx(\"questionnaire.xlsx\",sheet = \"survey\")\n\n# Step 2\nchoice_sheet <- readxl::read_xlsx(\"questionnaire.xlsx\",sheet = \"choices\")\n\n# Step 3\nsurvey_sheet <- survey_sheet |> tidyr::separate(type, into = c(\"type\", \"label_choice\"),sep = \" \")\n\n# Step 4\nvar_identifier <- NULL\n\nfor (i in 1:length(names(dataset))) {\n  if (names(dataset)[i] %in% survey_sheet$name) {\n    var_identifier <-  append(var_identifier,names(dataset)[i])\n  }\n}\n\n# Step 5\nvar_identifier <- as.data.frame(var_identifier)\n\nvar_identifier <- var_identifier |> dplyr::mutate(\n  label_choice = maditr::vlookup(lookup_value = var_identifier,dict = survey_sheet,lookup_column = \"name\",result_column = \"label_choice\")\n) |> na.omit()\n\nvar_identifier <- var_identifier |> dplyr::mutate(\n  label_var = maditr::vlookup(lookup_value = var_identifier,dict = survey_sheet,lookup_column = \"name\",result_column = \"label::English\")\n) \n\n# Step 6\nvar_identifier <- var_identifier |> dplyr::left_join(choice_sheet,by = c(\"label_choice\"=\"list_name\")) \n\nvar_identifier <- var_identifier |> dplyr::mutate(\n  new_var = paste(var_identifier,as.character(name),sep = \"_\")\n)\n\n# Step 7\ncol_to_apply <- unique(var_identifier$var_identifier)\n\nconcat_colname <- function(df, col_name) {\n  df[[col_name]] <- paste0(col_name, \"_\", df[[col_name]])\n  return(df)\n}\n# Step 8\nfor (col_name in col_to_apply) {\n  dataset <- concat_colname(dataset, col_name)\n}\n\n# Step 9 Optional\n# names(dataset) <- unique(dataset)\n# names(dataset) <- ifelse(is.na(names(dataset)) | names(dataset) == \"\", paste0(\"X\", seq_along(names(dataset))), names(dataset))\n\n# Step 10\ndataset <- dataset |> dplyr::mutate(\n  across(all_of(col_to_apply), ~  maditr::vlookup(lookup_value = .,dict = var_identifier,lookup_column = \"new_var\",result_column = \"label::English\"))\n)\n\ndatatable(head(dataset,3))\n```\n\n### III-3- How to get variable labels\n\nLe résultat de cette partie n'est normalement visible que dans Rstudio\n\n```{r warning=FALSE,message=FALSE}\n\nfor (i in seq_len(nrow(var_identifier))) {\n  var <- var_identifier$var_identifier[i]\n  lbl <- var_identifier$label_var[i]\n  if (var %in% names(dataset)) {\n    labelled::var_label(dataset[[var]]) <- lbl\n  }\n}\n\ndatatable(head(dataset,3))\n```\n","srcMarkdownNoYaml":"\n\n```{r echo=FALSE}\n  htmltools::img(src = knitr::image_uri(file.path(\"image/WFP-logo.png\")), \n               alt = 'logo', \n               style = 'position:absolute; top:5px; right:15px; padding:10px; max-width: 13%; max-height: 13%')\n```\n\n```{r setup, include=FALSE}\nknitr::opts_chunk$set(echo = TRUE)\n\nlibrary(DT)\n```\n\n## I- Introduction\n\n**NB** : **The IDs and Tokens are not linked to any WFP account. They are associated with a Gmail account created solely to facilitate understanding of how to use the package and to allow interested colleagues to replicate the exact same example, which they can then adapt to their own projects.**\n\nThe connectoModa package allows you to directly download a database stored in Moda from R. It also provides the ability to retrieve a list of team members with access to the project, along with their access levels. The main advantage is that it allows access to the database even when there are issues with Moda that prevent direct connection.\n\n## II- How to download a database\n\nTo download a database using the **connectoModa** package, it is necessary to log in to Moda at least once to obtain the project Form ID and token.\n\nThe Form ID is a numerical identifier that corresponds to the last digit displayed after selecting the project, as shown in the image below.\n\nTo obtain the token, select **Settings**, then **API Gateway**. The token is in alphanumeric format.\n\nformid ![Form_id](image/form_id.PNG) token ![Token](image/api_key2.PNG){width=\"476\"}\n\nWho has access to the database?\n\n```{r warning=FALSE}\nlibrary(connectoModa)\n\nget_user_moda(form_id = 202344,Token = \"ee9949e8875da3d7bbc63dfb6a8e1ac8d9989030\")\n\n```\n\nDownload the database.\n\n```{r warning=FALSE,message=FALSE}\ndataset <- get_data_moda(form_id = 202344,Token = \"ee9949e8875da3d7bbc63dfb6a8e1ac8d9989030\")\ndatatable(head(dataset,2))\n```\n\nThe package successfully downloaded the database. However, there is an issue: sections appear in the variable names, and for the variable \"sex\", instead of \"male\" and \"female,\" I have the values \"1\" and \"2.\" How can I fix this?\n\n![](image/issue.PNG){fig-align=\"center\" width=\"228\"}\n\n## III- How to have variable names and modalities instead of numbers?\n\n### III-1- Correct variable names\n\nTo correct the problem with variable names, I remove the text before the / symbol as follows\n\n```{r warning=FALSE,message=FALSE}\nnames(dataset) <- stringr::str_remove(names(dataset), \".*\\\\/\")\ndatatable(head(dataset,2))\n\n```\n\n### III-2- How to have the modalities of variables instead of numerical codes\n\nThis is the most important part of the guidance, as it's essential to know each modality associated with the variable codes. To get the modalities we have two choices: either we do it manually using the dplyr package's case_when() function, or we download the questionnaire and do a few manipulations with the for loops. The second method is the most appropriate, as manually recoding a database of over 500 variables can be tedious.\n\nTo use this method, you need to download the questionnaire from Moda and import it into R .\n\nThe questionnaire used in this example is available below:\n\n```{r echo=FALSE}\nxfun::embed_file(\"questionnaire.xlsx\")\n```\n\nThe first column of the **survey** sheet contains the elements of the first column of the **choice** sheet. For example, with select_one **sex** we find **sex** in the first column of the choice sheet. The following steps will provide the modalities:\n\n1.  Import survey sheet from questionnaire\n\n2.  Import choices sheet from questionnaire\n\n3.  Split the first column of the survey sheet into 2 columns\n\n4.  Create a Null vector in which to add all the variable names in the imported database that are identical to the names in column 2 of the survey sheet\n\n5.  Transform the vector into a dataframe, then use the vlooukup function to add the variables obtained by separating the first column of the survey sheet.\n\n6.  Make a left join with the choices sheet to obtain a dataframe with the choices elements.\n\n7.  Define the columns on which to apply the vlookup and create a function that associates each variable with its column content to facilitate the vlookup.\n\n8.  Associate each variable with modalities and its column contents.\n\n9.  (**Optional**) Remove duplicated variable names and give variable names to columns with empty names\n\n10. Apply the vlookup to the entire database.\n\n```{r warning=FALSE,message=FALSE}\n# Step 1\nsurvey_sheet <- readxl::read_xlsx(\"questionnaire.xlsx\",sheet = \"survey\")\n\n# Step 2\nchoice_sheet <- readxl::read_xlsx(\"questionnaire.xlsx\",sheet = \"choices\")\n\n# Step 3\nsurvey_sheet <- survey_sheet |> tidyr::separate(type, into = c(\"type\", \"label_choice\"),sep = \" \")\n\n# Step 4\nvar_identifier <- NULL\n\nfor (i in 1:length(names(dataset))) {\n  if (names(dataset)[i] %in% survey_sheet$name) {\n    var_identifier <-  append(var_identifier,names(dataset)[i])\n  }\n}\n\n# Step 5\nvar_identifier <- as.data.frame(var_identifier)\n\nvar_identifier <- var_identifier |> dplyr::mutate(\n  label_choice = maditr::vlookup(lookup_value = var_identifier,dict = survey_sheet,lookup_column = \"name\",result_column = \"label_choice\")\n) |> na.omit()\n\nvar_identifier <- var_identifier |> dplyr::mutate(\n  label_var = maditr::vlookup(lookup_value = var_identifier,dict = survey_sheet,lookup_column = \"name\",result_column = \"label::English\")\n) \n\n# Step 6\nvar_identifier <- var_identifier |> dplyr::left_join(choice_sheet,by = c(\"label_choice\"=\"list_name\")) \n\nvar_identifier <- var_identifier |> dplyr::mutate(\n  new_var = paste(var_identifier,as.character(name),sep = \"_\")\n)\n\n# Step 7\ncol_to_apply <- unique(var_identifier$var_identifier)\n\nconcat_colname <- function(df, col_name) {\n  df[[col_name]] <- paste0(col_name, \"_\", df[[col_name]])\n  return(df)\n}\n# Step 8\nfor (col_name in col_to_apply) {\n  dataset <- concat_colname(dataset, col_name)\n}\n\n# Step 9 Optional\n# names(dataset) <- unique(dataset)\n# names(dataset) <- ifelse(is.na(names(dataset)) | names(dataset) == \"\", paste0(\"X\", seq_along(names(dataset))), names(dataset))\n\n# Step 10\ndataset <- dataset |> dplyr::mutate(\n  across(all_of(col_to_apply), ~  maditr::vlookup(lookup_value = .,dict = var_identifier,lookup_column = \"new_var\",result_column = \"label::English\"))\n)\n\ndatatable(head(dataset,3))\n```\n\n### III-3- How to get variable labels\n\nLe résultat de cette partie n'est normalement visible que dans Rstudio\n\n```{r warning=FALSE,message=FALSE}\n\nfor (i in seq_len(nrow(var_identifier))) {\n  var <- var_identifier$var_identifier[i]\n  lbl <- var_identifier$label_var[i]\n  if (var %in% names(dataset)) {\n    labelled::var_label(dataset[[var]]) <- lbl\n  }\n}\n\ndatatable(head(dataset,3))\n```\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"knitr"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","self-contained":true,"toc":true,"output-file":"index.html"},"language":{"toc-title-document":"Table des matières","toc-title-website":"Sur cette page","related-formats-title":"Autres formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"La source","other-links-title":"Autres liens","code-links-title":"Liens de code","launch-dev-container-title":"Lancer le Dev Container","launch-binder-title":"Lancer le Binder","article-notebook-label":"Cahier d'articles","notebook-preview-download":"Télécharger le cahier","notebook-preview-download-src":"Télécharger le code source","notebook-preview-back":"Retour à l'article","manuscript-meca-bundle":"Archive MECA","section-title-abstract":"Résumé","section-title-appendices":"Annexes","section-title-footnotes":"Notes de bas de page","section-title-references":"Les références","section-title-reuse":"Réutilisation","section-title-copyright":"Droits d'auteur","section-title-citation":"Citation","appendix-attribution-cite-as":"Veuillez citer ce travail comme suit :","appendix-attribution-bibtex":"BibTeX","title-block-author-single":"RAM Officer","title-block-author-plural":"Auteur·rice·s","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Date de publication","title-block-modified":"Last update","title-block-keywords":"Mots clés","callout-tip-title":"Astuce","callout-note-title":"Note","callout-warning-title":"Avertissement","callout-important-title":"Important","callout-caution-title":"Mise en garde","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Montrer tout le code","code-tools-hide-all-code":"Cacher tout le code","code-tools-view-source":"Voir les sources","code-tools-source-code":"Code source","tools-share":"Share","tools-download":"Download","code-line":"Ligne","code-lines":"Lignes","copy-button-tooltip":"Copier vers le presse-papier","copy-button-tooltip-success":"Copié","repo-action-links-edit":"Modifier cette page","repo-action-links-source":"Voir la source","repo-action-links-issue":"Faire part d'un problème","back-to-top":"Retour au sommet","search-no-results-text":"Pas de résultats","search-matching-documents-text":"documents trouvés","search-copy-link-title":"Copier le lien vers la recherche","search-hide-matches-text":"Cacher les correspondances additionnelles","search-more-match-text":"correspondance de plus dans ce document","search-more-matches-text":"correspondances de plus dans ce document","search-clear-button-title":"Effacer","search-text-placeholder":"","search-detached-cancel-button-title":"Annuler","search-submit-button-title":"Envoyer","search-label":"Recherche","toggle-section":"Basculer la section","toggle-sidebar":"Basculer la barre latérale","toggle-dark-mode":"Basculer le mode sombre","toggle-reader-mode":"Basculer en mode lecteur","toggle-navigation":"Basculer la navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Théorème","crossref-lem-title":"Lemme","crossref-cor-title":"Corollaire","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Définition","crossref-exm-title":"Exemple","crossref-exr-title":"Exercice","crossref-ch-prefix":"Chapitre","crossref-apx-prefix":"Annexe","crossref-sec-prefix":"Section","crossref-eq-prefix":"Équation","crossref-lof-title":"Liste des Figures","crossref-lot-title":"Liste des Tables","crossref-lol-title":"Liste des Listings","environment-proof-title":"Preuve","environment-remark-title":"Remarque","environment-solution-title":"Solution","listing-page-order-by":"Trier par","listing-page-order-by-default":"Ordre par défaut","listing-page-order-by-date-asc":"Le plus ancien","listing-page-order-by-date-desc":"Le plus récent","listing-page-order-by-number-desc":"Descendant","listing-page-order-by-number-asc":"Ascendant","listing-page-field-date":"Date","listing-page-field-title":"Titre","listing-page-field-description":"Description","listing-page-field-author":"Auteur·rice","listing-page-field-filename":"Nom de fichier","listing-page-field-filemodified":"Modifié","listing-page-field-subtitle":"Sous-titre","listing-page-field-readingtime":"Temps de lecture","listing-page-field-wordcount":"Compteur de Mots","listing-page-field-categories":"Catégories","listing-page-minutes-compact":"{0} min.","listing-page-category-all":"Tous","listing-page-no-matches":"Aucun article correspondant","listing-page-words":"{0} mots"},"metadata":{"lang":"fr","fig-responsive":true,"quarto-version":"1.4.552","title":"Guidance connectoModa","author":"Idrissa DABO","title-block-banner":"#D7DBDD","date-modified":"08/24/2024 01:11","date-format":"MM/D/YYYY, HH:mm","editor":"visual","toc-location":"right"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":[]}